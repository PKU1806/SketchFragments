/*
 * @Author: Leo Appleby 
 * @Date: 2020-08-01 16:36:28 
 * @Last Modified by: Leo Appleby
 * @Last Modified time: 2020-08-08 20:57:04
 */

# file/folder introduction
log&pcap:sth generated by certain tools

p4src:the p4 code implementation

monitor.py: switch the sketches 

p4app.json : topology description and some network setting

routing-controller.py : under the l3 net , we use this to fill our router table and other table. `initializer`:run it after mininet starts

simple_receiver:implemented using scapy, dismantle the packet and show info

simple_sender: send udp/tcp packet (default: 1  udp  packet),usage:using -h to see

log_generator.py:get the CPU packet from a specific switch and generate logs

error.py:gen loop or blackhole for the net,could also reset the net

visor.py:list the sketch's value of switches

# the testing method
## basic step 
1. get into the `../switch` folder
2. activate tmux and create duplicate windows
3. window A as the mininet console ,type ` sudo p4run ` to evoke the mininet
4. when the mininet_env is established, type `python routing-controller.py`  to set the tables in window B

## send packet & receive packet & listen to switch
5. in window C,type `mx h1` and type `python simple_sender.py -h` to send packet from h1 and get help
6. in window D,type `mx h4` and type `python simple_receiver.py` to listen from a eth port
7. in window B (after mini-step4),type `mx s7` ,and `python test.py -h` to minitor control plane of s7 


## question & problems 
1. why icmp will fail when s1 shutdown while udp will be ok: 1. ecmp 2. parser 3.the send back?
   SOLVED:by add a item in the hash of ecmp;
   BUT mininet `pingall` instruction may show that some hosts are still not connected yet, but using our sender/receiver,we can prove they are actually connected via tcp icmp and udp 
2. the packet's compatibility

